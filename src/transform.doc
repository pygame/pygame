pygame.transform
pygame module to transform surfaces

A Surface transform is an operation that moves or resizes the pixels. All
these functions take a Surface to operate on and return a new Surface with
the results.

Some of the transforms are considered destructive. These means every time
they are performed they lose pixel data. Common examples of this are resizing
and rotating. For this reason, it is better to retransform the original surface than to 
keep transforming an image multiple times. (For example, suppose you are animating
a bouncing spring which expands and contracts. If you applied the size changes
incrementally to the previous images, you would lose detail. Instead, always
begin with the original image and scale to the desired size.)
<SECTION>



flip
flip vertically and horizontally
pygame.transform.flip(Surface, xbool, ybool): return Surface

This can flip a Surface either vertically, horizontally, or both. Flipping
a Surface is nondestructive and returns a new Surface with the same dimensions.
<END>



scale
resize to new resolution
pygame.transform.scale(Surface, (width, height), DestSurface = None): return Surface

Resizes the Surface to a new resolution. This is a fast scale operation
that does not sample the results. 

An optional destination surface can be used, rather than have it create 
a new one.  This is quicker if you want to repeatedly scale something.  
However the destination must be the same size as the (width, height) passed 
in.  Also the destination surface must be the same format.
<END>



rotate
rotate an image
pygame.transform.rotate(Surface, angle): return Surface

Unfiltered counterclockwise rotation. The angle argument represents degrees
and can be any floating point value. Negative angle amounts will rotate
clockwise.

Unless rotating by 90 degree increments, the image will be padded larger
to hold the new size. If the image has pixel alphas, the padded area will
be transparent. Otherwise pygame will pick a color that matches the Surface
colorkey or the topleft pixel value.
<END>



rotozoom
filtered scale and rotation
pygame.transform.rotozoom(Surface, angle, scale): return Surface

This is a combined scale and rotation transform. The resulting Surface will
be a filtered 32-bit Surface. The scale argument is a floating point value
that will be multiplied by the current resolution. The angle argument is
a floating point value that represents the counterclockwise degrees to
rotate. A negative rotation angle will rotate clockwise.
<END>



scale2x
specialized image doubler
pygame.transform.scale2x(Surface, DestSurface = None): Surface

This will return a new image that is double the size of the original. It uses
the AdvanceMAME Scale2X algorithm which does a 'jaggie-less' scale of bitmap
graphics.
 
This really only has an effect on simple images with solid colors. On
photographic and antialiased images it will look like a regular unfiltered
scale.

An optional destination surface can be used, rather than have it create 
a new one.  This is quicker if you want to repeatedly scale something.  
However the destination must be twice the size of the source surface passed 
in.  Also the destination surface must be the same format.
<END>



smoothscale
scale a surface to an arbitrary size smoothly
pygame.transform.smoothscale(Surface, (width, height), DestSurface = None): return Surface

Uses one of two different algorithms for scaling each
dimension of the input surface as required.  For shrinkage,
the output pixels are area averages of the colors they
cover.  For expansion, a bilinear filter is used. For the
amd64 and i686 architectures, optimized MMX routines are
included and will run much faster than other machine types.
The size is a 2 number sequence for (width, height). This
function only works for 24-bit or 32-bit surfaces.  An
exception will be thrown if the input surface bit depth is
less than 24.

New in pygame 1.8
<END>



chop
gets a copy of an image with an interior area removed
pygame.transform.chop(Surface, rect): return Surface

Extracts a portion of an image. All vertical and
horizontal pixels surrounding the given rectangle area are removed.
The corner areas (diagonal to the rect) are then brought together.
(The original image is not altered by this operation.)

NOTE: If you want a "crop" that returns the part of an image within
a rect, you can blit with a rect to a new surface or copy a subsurface. 
<END>



laplacian
find edges in a surface
pygame.transform.laplacian(Surface, DestSurface = None): return Surface

Finds the edges in a surface using the laplacian algorithm.

New in pygame 1.8
<END>



average_surfaces
find the average surface from many surfaces.
pygame.transform.average_surfaces(Surfaces, DestSurface = None): return Surface

Takes a sequence of surfaces and returns a surface with average colors from each
of the surfaces.

New in pygame 1.8
<END>



threshold
finds which, and how many pixels in a surface are within a threshold of a color.

pygame.transform.threshold(DestSurface, Surface, color, threshold = (0,0,0,0), diff_color = (0,0,0,0), change_return = True, Surface =None): return num_threshold_pixels

It can set the destination surface where all of the pixels not within the 
threshold are changed to diff_color.

Or it can be used to just count the number of pixels within the threshold if you set
change_return to False.

When given the optional third surface, it will use the colors in that rather 
than the 3rd position "color" arg.

You can use a threshold of (r,g,b,a) where the r,g,b can have different thresholds. So
you could use an r threshold of 40 and a blue threshold of 2 if you like.

New in pygame 1.8
<END>
<END>
