
<html>
<title>midi - Pygame Documentation</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellpadding=0 cellspacing=0 border=0 style='border: 3px solid black;' width='100%'>
<tr>
<td bgcolor='#c2fc20' style='padding: 6px;' align=center valign=center><a href='http://www.pygame.org/'><img src='../pygame_tiny.gif' border=0 width=200 height=60></a><br><b>pygame documentation</b></td>
<td bgcolor='#6aee28' style='border-left: 3px solid black; padding: 6px;' align=center valign=center>
	||&nbsp;
	<a href=http://www.pygame.org>Pygame Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<a href=index.html>Reference Index</a> &nbsp;||
	<br>&nbsp;<br>
	
<a href="camera.html">Camera</a>&nbsp;||&nbsp;
<a href="cdrom.html">Cdrom</a>&nbsp;||&nbsp;
<a href="color.html">Color</a>&nbsp;||&nbsp;
<a href="cursors.html">Cursors</a>&nbsp;||&nbsp;
<a href="display.html">Display</a>&nbsp;||&nbsp;
<a href="draw.html">Draw</a>&nbsp;||&nbsp;
<a href="event.html">Event</a>&nbsp;||&nbsp;
<a href="examples.html">Examples</a>&nbsp;||&nbsp;
<a href="font.html">Font</a>&nbsp;||&nbsp;
<a href="gfxdraw.html">Gfxdraw</a>&nbsp;||&nbsp;
<a href="image.html">Image</a>&nbsp;||&nbsp;
<a href="joystick.html">Joystick</a>&nbsp;||&nbsp;
<a href="key.html">Key</a>&nbsp;||&nbsp;
<a href="locals.html">Locals</a>&nbsp;||&nbsp;
<a href="mask.html">Mask</a>&nbsp;||&nbsp;
<a href="midi.html">Midi</a>&nbsp;||&nbsp;
<a href="mixer.html">Mixer</a>&nbsp;||&nbsp;
<a href="mouse.html">Mouse</a>&nbsp;||&nbsp;
<a href="movie.html">Movie</a>&nbsp;||&nbsp;
<a href="music.html">Music</a>&nbsp;||&nbsp;
<a href="overlay.html">Overlay</a>&nbsp;||&nbsp;
<a href="pixelarray.html">Pixelarray</a>&nbsp;||&nbsp;
<a href="pygame.html">Pygame</a>&nbsp;||&nbsp;
<a href="rect.html">Rect</a>&nbsp;||&nbsp;
<a href="scrap.html">Scrap</a>&nbsp;||&nbsp;
<a href="sndarray.html">Sndarray</a>&nbsp;||&nbsp;
<a href="sprite.html">Sprite</a>&nbsp;||&nbsp;
<a href="surface.html">Surface</a>&nbsp;||&nbsp;
<a href="surfarray.html">Surfarray</a>&nbsp;||&nbsp;
<a href="tests.html">Tests</a>&nbsp;||&nbsp;
<a href="time.html">Time</a>&nbsp;||&nbsp;
<a href="transform.html">Transform</a>
</td></tr></table>
<br>


<a name="pygame.midi">
<big><b>pygame.midi</big></b><br><ul>
  <i>pygame module for interacting with midi input and output.</i><br>
<ul><small><table>
  <tr><td><a href="midi.html#pygame.midi.Input">pygame.midi.Input</a> - <font size=-1>Input is used to get midi input from midi devices.</font></td><td>Input is used to get midi input from midi devices.</td></tr>
  <tr><td><a href="midi.html#pygame.midi.MidiException">pygame.midi.MidiException</a> - <font size=-1>exception that pygame.midi functions and classes can raise</font></td><td>exception that pygame.midi functions and classes can raise</td></tr>
  <tr><td><a href="midi.html#pygame.midi.Output">pygame.midi.Output</a> - <font size=-1>Output is used to send midi to an output device</font></td><td>Output is used to send midi to an output device</td></tr>
  <tr><td><a href="midi.html#pygame.midi.get_count">pygame.midi.get_count</a> - <font size=-1>gets the number of devices.</font></td><td>gets the number of devices.</td></tr>
  <tr><td><a href="midi.html#pygame.midi.get_default_input_id">pygame.midi.get_default_input_id</a> - <font size=-1>gets default input device number</font></td><td>gets default input device number</td></tr>
  <tr><td><a href="midi.html#pygame.midi.get_default_output_id">pygame.midi.get_default_output_id</a> - <font size=-1>gets default output device number</font></td><td>gets default output device number</td></tr>
  <tr><td><a href="midi.html#pygame.midi.get_device_info">pygame.midi.get_device_info</a> - <font size=-1> returns information about a midi device</font></td><td> returns information about a midi device</td></tr>
  <tr><td><a href="midi.html#pygame.midi.init">pygame.midi.init</a> - <font size=-1>initialize the midi module</font></td><td>initialize the midi module</td></tr>
  <tr><td><a href="midi.html#pygame.midi.midis2events">pygame.midi.midis2events</a> - <font size=-1>converts midi events to pygame events</font></td><td>converts midi events to pygame events</td></tr>
  <tr><td><a href="midi.html#pygame.midi.quit">pygame.midi.quit</a> - <font size=-1>uninitialize the midi module</font></td><td>uninitialize the midi module</td></tr>
  <tr><td><a href="midi.html#pygame.midi.time">pygame.midi.time</a> - <font size=-1>returns the current time in ms of the PortMidi timer</font></td><td>returns the current time in ms of the PortMidi timer</td></tr>
</table></small></ul>
<p>The midi module can send output to midi devices, and get input from midi devices. It can also list midi devices on the system. </p>
<p>Including real midi devices, and virtual ones. </p>
<p>It uses the portmidi library. Is portable to which ever platforms portmidi supports (currently windows, <tt>OSX</tt>, and linux). </p>
<p>This uses pyportmidi for now, but may use its own bindings at some point in the future. The pyportmidi bindings are included with pygame. </p>
<p>New in pygame <tt>1.9.0</tt>. </p>
<!--COMMENTS:pygame.midi--> &nbsp;<br> 


<a name="pygame.midi.Input">
<big><b>pygame.midi.Input</big></b><br><ul>
  <i>Input is used to get midi input from midi devices.</i><br>
  <tt>Input(device_id)</tt><br>
  <tt>Input(device_id, buffer_size)</tt><br>
<ul><small><table>
  <tr><td><a href="midi.html#Input.close">Input.close</a> - <font size=-1> closes a midi stream, flushing any pending buffers.</font></td><td> closes a midi stream, flushing any pending buffers.</td></tr>
  <tr><td><a href="midi.html#Input.poll">Input.poll</a> - <font size=-1>returns true if there's data, or false if not.</font></td><td>returns true if there's data, or false if not.</td></tr>
  <tr><td><a href="midi.html#Input.read">Input.read</a> - <font size=-1>reads num_events midi events from the buffer.</font></td><td>reads num_events midi events from the buffer.</td></tr>
</table></small></ul>
<p>buffer_size -the number of input events to be buffered waiting to </p>
<pre>  be read using Input.read()
</pre>
<!--COMMENTS:pygame.midi.Input--> &nbsp;<br> 


<a name="Input.close">
<big><b>Input.close</big></b><br><ul>
  <i> closes a midi stream, flushing any pending buffers.</i><br>
  <tt>Input.close(): return None</tt><br>
<p>PortMidi attempts to close open streams when the application exits -- this is particularly difficult under Windows. </p>
<!--COMMENTS:Input.close--> &nbsp;<br> 
<br></ul>


<a name="Input.poll">
<big><b>Input.poll</big></b><br><ul>
  <i>returns true if there's data, or false if not.</i><br>
  <tt>Input.poll(): return Bool</tt><br>
<p>raises a MidiException on error. </p>
<!--COMMENTS:Input.poll--> &nbsp;<br> 
<br></ul>


<a name="Input.read">
<big><b>Input.read</big></b><br><ul>
  <i>reads num_events midi events from the buffer.</i><br>
  <tt>Input.read(num_events): return midi_event_list</tt><br>
<p>Reads from the Input buffer and gives back midi events. [[[status,data1,data2,data3],timestamp], </p>
<pre> [[status,data1,data2,data3],timestamp],...]
</pre>
<!--COMMENTS:Input.read--> &nbsp;<br> 
<br></ul>
<br></ul>


<a name="pygame.midi.MidiException">
<big><b>pygame.midi.MidiException</big></b><br><ul>
  <i>exception that pygame.midi functions and classes can raise</i><br>
  <tt>MidiException(errno)</tt><br>
 &nbsp;<br> 
<!--COMMENTS:pygame.midi.MidiException--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.Output">
<big><b>pygame.midi.Output</big></b><br><ul>
  <i>Output is used to send midi to an output device</i><br>
  <tt>Output(device_id)</tt><br>
  <tt>Output(device_id, latency = 0)</tt><br>
  <tt>Output(device_id, buffer_size = 4096)</tt><br>
  <tt>Output(device_id, latency, buffer_size)</tt><br>
<ul><small><table>
  <tr><td><a href="midi.html#Output.abort">Output.abort</a> - <font size=-1> terminates outgoing messages immediately</font></td><td> terminates outgoing messages immediately</td></tr>
  <tr><td><a href="midi.html#Output.close">Output.close</a> - <font size=-1> closes a midi stream, flushing any pending buffers.</font></td><td> closes a midi stream, flushing any pending buffers.</td></tr>
  <tr><td><a href="midi.html#Output.note_off">Output.note_off</a> - <font size=-1>turns a midi note off.  Note must be on.</font></td><td>turns a midi note off.  Note must be on.</td></tr>
  <tr><td><a href="midi.html#Output.note_on">Output.note_on</a> - <font size=-1>turns a midi note on.  Note must be off.</font></td><td>turns a midi note on.  Note must be off.</td></tr>
  <tr><td><a href="midi.html#Output.set_instrument">Output.set_instrument</a> - <font size=-1>select an instrument, with a value between 0 and 127</font></td><td>select an instrument, with a value between 0 and 127</td></tr>
  <tr><td><a href="midi.html#Output.write">Output.write</a> - <font size=-1>writes a list of midi data to the Output</font></td><td>writes a list of midi data to the Output</td></tr>
  <tr><td><a href="midi.html#Output.write_short">Output.write_short</a> - <font size=-1>write_short(status <, data1><, data2>)</font></td><td>write_short(status <, data1><, data2>)</td></tr>
  <tr><td><a href="midi.html#Output.write_sys_ex">Output.write_sys_ex</a> - <font size=-1>writes a timestamped system-exclusive midi message.</font></td><td>writes a timestamped system-exclusive midi message.</td></tr>
</table></small></ul>
<p>The buffer_size specifies the number of output events to be buffered waiting for output. (In some cases -- see below -- PortMidi does not buffer output at all and merely passes data to a lower-level <tt>API</tt>, in which case buffersize is <tt>ignored.)</tt> </p>
<p>latency is the delay in milliseconds applied to timestamps to determine when the output should actually occur. (If latency is < 0, 0 is <tt>assumed.)</tt> </p>
<p>If latency is zero, timestamps are ignored and all output is delivered immediately. If latency is greater than zero, output is delayed until the message timestamp plus the latency. <tt>(NOTE:</tt> time is measured relative to the time source indicated by time_proc. Timestamps are absolute, not relative delays or <tt>offsets.)</tt> In some cases, PortMidi can obtain better timing than your application by passing timestamps along to the device driver or hardware. Latency may also help you to synchronize midi data to audio data by matching midi latency to the audio buffer latency. </p>
<!--COMMENTS:pygame.midi.Output--> &nbsp;<br> 


<a name="Output.abort">
<big><b>Output.abort</big></b><br><ul>
  <i> terminates outgoing messages immediately</i><br>
  <tt>Output.abort(): return None</tt><br>
<p>The caller should immediately close the output port; this call may result in transmission of a partial midi message. There is no abort for Midi input because the user can simply ignore messages in the buffer and close an input device at any time. </p>
<!--COMMENTS:Output.abort--> &nbsp;<br> 
<br></ul>


<a name="Output.close">
<big><b>Output.close</big></b><br><ul>
  <i> closes a midi stream, flushing any pending buffers.</i><br>
  <tt>Output.close(): return None</tt><br>
<p>PortMidi attempts to close open streams when the application exits -- this is particularly difficult under Windows. </p>
<!--COMMENTS:Output.close--> &nbsp;<br> 
<br></ul>


<a name="Output.note_off">
<big><b>Output.note_off</big></b><br><ul>
  <i>turns a midi note off.  Note must be on.</i><br>
  <tt>Output.note_off(note, velocity=None, channel = 0)</tt><br>
<p>Turn a note off in the output stream. The note must already be on for this to work correctly. </p>
<!--COMMENTS:Output.note_off--> &nbsp;<br> 
<br></ul>


<a name="Output.note_on">
<big><b>Output.note_on</big></b><br><ul>
  <i>turns a midi note on.  Note must be off.</i><br>
  <tt>Output.note_on(note, velocity=None, channel = 0)</tt><br>
<p>Turn a note on in the output stream. The note must already be off for this to work correctly. </p>
<!--COMMENTS:Output.note_on--> &nbsp;<br> 
<br></ul>


<a name="Output.set_instrument">
<big><b>Output.set_instrument</big></b><br><ul>
  <i>select an instrument, with a value between 0 and 127</i><br>
  <tt>Output.set_instrument(instrument_id, channel = 0)</tt><br>
 &nbsp;<br> 
<!--COMMENTS:Output.set_instrument--> &nbsp;<br> 
<br></ul>


<a name="Output.write">
<big><b>Output.write</big></b><br><ul>
  <i>writes a list of midi data to the Output</i><br>
  <tt>Output.write(data)</tt><br>
<p>writes series of <tt>MIDI</tt> information in the form of a list: </p>
<pre>     write([[[status <,data1><,data2><,data3>],timestamp],
            [[status <,data1><,data2><,data3>],timestamp],...])
</pre><p><data> fields are optional example: choose program change 1 at time 20000 and send note 65 with velocity 100 500 ms later. </p>
<pre>     write([[[0xc0,0,0],20000],[[0x90,60,100],20500]])
</pre><p>notes: </p>
<pre>  1. timestamps will be ignored if latency = 0.
  2. To get a note to play immediately, send MIDI info with
     timestamp read from function Time.
  3. understanding optional data fields:
       write([[[0xc0,0,0],20000]]) is equivalent to
       write([[[0xc0],20000]])
</pre><p>Can send up to 1024 elements in your data list, otherwise an </p>
<pre> IndexError exception is raised.
</pre>
<!--COMMENTS:Output.write--> &nbsp;<br> 
<br></ul>


<a name="Output.write_short">
<big><b>Output.write_short</big></b><br><ul>
  <i>write_short(status <, data1><, data2>)</i><br>
  <tt>Output.write_short(status)</tt><br>
  <tt>Output.write_short(status, data1 = 0, data2 = 0)</tt><br>
<p>output <tt>MIDI</tt> information of 3 bytes or less. data fields are optional status byte could be: </p>
<pre>     0xc0 = program change
     0x90 = note on
     etc.
     data bytes are optional and assumed 0 if omitted
</pre><p>example: note 65 on with velocity 100 </p>
<pre>     write_short(0x90,65,100)
</pre>
<!--COMMENTS:Output.write_short--> &nbsp;<br> 
<br></ul>


<a name="Output.write_sys_ex">
<big><b>Output.write_sys_ex</big></b><br><ul>
  <i>writes a timestamped system-exclusive midi message.</i><br>
  <tt>Output.write_sys_ex(when, msg)</tt><br>
<p>msg - can be a *list* or a *string* when - a timestamp in miliseconds example: </p>
<pre>  (assuming o is an onput MIDI stream)
    o.write_sys_ex(0,'\xF0\x7D\x10\x11\x12\x13\xF7')
  is equivalent to
    o.write_sys_ex(pygame.midi.time(),
                   [0xF0,0x7D,0x10,0x11,0x12,0x13,0xF7])
</pre>
<!--COMMENTS:Output.write_sys_ex--> &nbsp;<br> 
<br></ul>
<br></ul>


<a name="pygame.midi.get_count">
<big><b>pygame.midi.get_count</big></b><br><ul>
  <i>gets the number of devices.</i><br>
  <tt>pygame.midi.get_count(): return num_devices</tt><br>
<p>Device ids range from 0 to get_count() -1 </p>
<!--COMMENTS:pygame.midi.get_count--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.get_default_input_id">
<big><b>pygame.midi.get_default_input_id</big></b><br><ul>
  <i>gets default input device number</i><br>
  <tt>pygame.midi.get_default_input_id(): return default_id</tt><br>
<p>Return the default device <tt>ID</tt> or -1 if there are no devices. The result can be passed to the Input()/Ouput() class. </p>
<p>On the <tt>PC</tt>, the user can specify a default device by setting an environment variable. For example, to use device #1. </p>
<pre>    set PM_RECOMMENDED_INPUT_DEVICE=1
</pre><p>The user should first determine the available device <tt>ID</tt> by using the supplied application "testin" or "testout". </p>
<p>In general, the registry is a better place for this kind of info, and with <tt>USB</tt> devices that can come and go, using integers is not very reliable for device identification. Under Windows, if <tt>PM_RECOMMENDED_OUTPUT_DEVICE</tt> (or <tt>PM_RECOMMENDED_INPUT_DEVICE)</tt> is <tt>*NOT*</tt> found in the environment, then the default device is obtained by looking for a string in the registry under: </p>
<pre>    HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device
</pre><p>and HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device for a string. The number of the first device with a substring that matches the string exactly is returned. For example, if the string in the registry is <tt>"USB"</tt>, and device 1 is named "In <tt>USB</tt> MidiSport 1x1", then that will be the default input because it contains the string <tt>"USB"</tt>. </p>
<p>In addition to the name, get_device_info() returns "interf", which is the interface name. (The "interface" is the underlying software system or <tt>API</tt> used by PortMidi to access devices. Examples are MMSystem, DirectX (not implemented), <tt>ALSA</tt>, <tt>OSS</tt> (not implemented), <tt>etc.)</tt> At present, the only Win32 interface is "MMSystem", the only Linux interface is <tt>"ALSA"</tt>, and the only Max <tt>OS</tt> <tt>X</tt> interface is "CoreMIDI". To specify both the interface and the device name in the registry, separate the two with a comma and a space, <tt>e.g.:</tt> </p>
<pre>    MMSystem, In USB MidiSport 1x1
</pre><p>In this case, the string before the comma must be a substring of the "interf" string, and the string after the space must be a substring of the "name" name string in order to match the device. </p>
<p>Note: in the current release, the default is simply the first device (the input or output device with the lowest PmDeviceID). </p>
<!--COMMENTS:pygame.midi.get_default_input_id--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.get_default_output_id">
<big><b>pygame.midi.get_default_output_id</big></b><br><ul>
  <i>gets default output device number</i><br>
  <tt>pygame.midi.get_default_output_id(): return default_id</tt><br>
<p>Return the default device <tt>ID</tt> or -1 if there are no devices. The result can be passed to the Input()/Ouput() class. </p>
<p>On the <tt>PC</tt>, the user can specify a default device by setting an environment variable. For example, to use device #1. </p>
<pre>    set PM_RECOMMENDED_OUTPUT_DEVICE=1
</pre><p>The user should first determine the available device <tt>ID</tt> by using the supplied application "testin" or "testout". </p>
<p>In general, the registry is a better place for this kind of info, and with <tt>USB</tt> devices that can come and go, using integers is not very reliable for device identification. Under Windows, if <tt>PM_RECOMMENDED_OUTPUT_DEVICE</tt> (or <tt>PM_RECOMMENDED_INPUT_DEVICE)</tt> is <tt>*NOT*</tt> found in the environment, then the default device is obtained by looking for a string in the registry under: </p>
<pre>    HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device
</pre><p>and HKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device for a string. The number of the first device with a substring that matches the string exactly is returned. For example, if the string in the registry is <tt>"USB"</tt>, and device 1 is named "In <tt>USB</tt> MidiSport 1x1", then that will be the default input because it contains the string <tt>"USB"</tt>. </p>
<p>In addition to the name, get_device_info() returns "interf", which is the interface name. (The "interface" is the underlying software system or <tt>API</tt> used by PortMidi to access devices. Examples are MMSystem, DirectX (not implemented), <tt>ALSA</tt>, <tt>OSS</tt> (not implemented), <tt>etc.)</tt> At present, the only Win32 interface is "MMSystem", the only Linux interface is <tt>"ALSA"</tt>, and the only Max <tt>OS</tt> <tt>X</tt> interface is "CoreMIDI". To specify both the interface and the device name in the registry, separate the two with a comma and a space, <tt>e.g.:</tt> </p>
<pre>    MMSystem, In USB MidiSport 1x1
</pre><p>In this case, the string before the comma must be a substring of the "interf" string, and the string after the space must be a substring of the "name" name string in order to match the device. </p>
<p>Note: in the current release, the default is simply the first device (the input or output device with the lowest PmDeviceID). </p>
<!--COMMENTS:pygame.midi.get_default_output_id--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.get_device_info">
<big><b>pygame.midi.get_device_info</big></b><br><ul>
  <i> returns information about a midi device</i><br>
  <tt>pygame.midi.get_device_info(an_id): return (interf, name, input, output, opened)</tt><br>
<p>interf - a text string describing the device interface, eg <tt>'ALSA'</tt>. name - a text string for the name of the device, eg 'Midi Through Port-0' input - 0, or 1 if the device is an input device. output - 0, or 1 if the device is an output device. opened - 0, or 1 if the device is opened. </p>
<p>If the id is out of range, the function returns None. </p>
<!--COMMENTS:pygame.midi.get_device_info--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.init">
<big><b>pygame.midi.init</big></b><br><ul>
  <i>initialize the midi module</i><br>
  <tt>pygame.midi.init(): return None</tt><br>
<p>Call the initialisation function before using the midi module. </p>
<p>It is safe to call this more than once. </p>
<!--COMMENTS:pygame.midi.init--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.midis2events">
<big><b>pygame.midi.midis2events</big></b><br><ul>
  <i>converts midi events to pygame events</i><br>
  <tt>pygame.midi.midis2events(midis, device_id): return [Event, ...]</tt><br>
<p>Takes a sequence of midi events and returns list of pygame events. </p>
<!--COMMENTS:pygame.midi.midis2events--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.quit">
<big><b>pygame.midi.quit</big></b><br><ul>
  <i>uninitialize the midi module</i><br>
  <tt>pygame.midi.quit(): return None</tt><br>
<p>Called automatically atexit if you don't call it. </p>
<p>It is safe to call this function more than once. </p>
<!--COMMENTS:pygame.midi.quit--> &nbsp;<br> 
<br></ul>


<a name="pygame.midi.time">
<big><b>pygame.midi.time</big></b><br><ul>
  <i>returns the current time in ms of the PortMidi timer</i><br>
  <tt>pygame.midi.time(): return time</tt><br>
<p>The time is reset to 0, when the module is inited. </p>
<!--COMMENTS:pygame.midi.time--> &nbsp;<br> 
<br></ul>
<br></ul>

</body></html>
