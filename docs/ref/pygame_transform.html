<html>
<title>pygame.transform</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellspacing=3 width=100%><tr><td bgcolor=#00000>
<table width=100%><tr><td bgcolor=c2fc20 align=center>
    <a href=http://www.pygame.org>
    <img src=../pygame_tiny.gif border=0 width=200 height=60></a><br>
    <b>pygame&nbsp;&nbsp;&nbsp;documentation</b>
</td><td bgcolor=6aee28 align=center valign=top width=100%>

	||&nbsp;
	<a href=http://www.pygame.org>Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<br>&nbsp;<br>

|| <a href=pygame.html>pygame</a> || 
<a href=pygame_cdrom.html>cdrom</a> || 
<a href=pygame_constants.html>constants</a> || 
<a href=pygame_display.html>display</a> || 
<a href=pygame_draw.html>draw</a> || 
<a href=pygame_event.html>event</a> ||<br>
|| <a href=pygame_font.html>font</a> || 
<a href=pygame_image.html>image</a> || 
<a href=pygame_joystick.html>joystick</a> || 
<a href=pygame_key.html>key</a> || 
<a href=pygame_mixer.html>mixer</a> || 
<a href=pygame_mixer_music.html>mixer_music</a> ||<br>
|| <a href=pygame_mouse.html>mouse</a> || 
<a href=pygame_movie.html>movie</a> || 
<a href=pygame_sndarray.html>sndarray</a> || 
<a href=pygame_surfarray.html>surfarray</a> || 
<a href=pygame_time.html>time</a> || 
<a href=pygame_transform.html>transform</a> ||<br>
&nbsp;<br>|| <a href=CD.html>CD</a> || 
<a href=Channel.html>Channel</a> || 
<a href=Clock.html>Clock</a> || 
<a href=Font.html>Font</a> || 
<a href=Joystick.html>Joystick</a> || 
<a href=Movie.html>Movie</a> ||<br>
|| <a href=Rect.html>Rect</a> || 
<a href=Sound.html>Sound</a> || 
<a href=Surface.html>Surface</a> ||<br>
&nbsp;<br>|| <a href=pygame_color.html>color</a> || 
<a href=pygame_cursors.html>cursors</a> || 
<a href=pygame_sprite.html>sprite</a> ||<br>


</td></tr></table></td></tr></table>
<br>
<h2 align=center>pygame.transform</h2>
Contains routines to transform a Surface image.
<br>&nbsp;<br>
All transformation functions take a source Surface and
return a new copy of that surface in the same format as
the original.
<br>&nbsp;<br>
Some of the
filters are 'destructive', which means if you transform
the image one way, you can't transform the image back to
the exact same way as it was before. If you plan on doing
many transforms, it is good practice to keep the original
untransformed image, and only translate that image.

<hr>

<table>
<tr><td><a href=#flip>flip</a></td><td> -
flips a surface on either axis</td></tr>


<tr><td><a href=#rotate>rotate</a></td><td> -
rotate a Surface</td></tr>


<tr><td><a href=#rotozoom>rotozoom</a></td><td> -
smoothly scale and/or rotate an image</td></tr>


<tr><td><a href=#scale>scale</a></td><td> -
scale a Surface to an arbitrary size</td></tr>


<tr><td><a href=#scale2x>scale2x</a></td><td> -
doubles the size of the image with advanced scaling</td></tr>


</table>

<hr>

<a name=flip><font size=+2><b>flip
</b></font><br><font size=+1><tt>
pygame.transform.flip(Surface, xaxis, yaxis) -> Surface
</tt></font><ul>
Flips the image on the x-axis or the y-axis if the argument
for that axis is true.
<br>&nbsp;<br>
The flip operation is nondestructive, you may flip the image
as many times as you like, and always be able to recreate the
exact original image.
</ul><br>&nbsp;<br>

<a name=rotate><font size=+2><b>rotate
</b></font><br><font size=+1><tt>
pygame.transform.rotate(Surface, angle) -> Surface
</tt></font><ul>
Rotates the image counterclockwise with the given angle
(in degrees). The angle can be any floating point value
(negative rotation amounts will do clockwise rotations)
<br>&nbsp;<br>
Unless rotating by 90 degree increments, the resulting image
size will be larger than the original. There will be newly
uncovered areas in the image. These will filled with either
the current colorkey for the Surface, or the topleft pixel value.
(with the alpha channel zeroed out if available)
<br>&nbsp;<br>
This transformation is not filtered.
</ul><br>&nbsp;<br>

<a name=rotozoom><font size=+2><b>rotozoom
</b></font><br><font size=+1><tt>
pygame.transform.rotozoom(Surface, angle, zoom) -> Surface
</tt></font><ul>
The angle argument is the number of degrees to rotate
counter-clockwise. The angle can be any floating point value.
(negative rotation amounts will do clockwise rotations)
<br>&nbsp;<br>
This will smoothly rotate and scale an image in one pass.
The resulting image will always be a 32bit version of the
original surface. The scale is a multiplier for the image
size, and angle is the degrees to rotate counter clockwise.
<br>&nbsp;<br>
It calls the SDL_rotozoom library which is compiled in.
Note that the code in SDL_rotozoom is fairly messy and your
resulting image could be shifted and contain artifacts.
</ul><br>&nbsp;<br>

<a name=scale><font size=+2><b>scale
</b></font><br><font size=+1><tt>
pygame.transform.scale(Surface, size) -> Surface
</tt></font><ul>
This will resize a surface to the given resolution.
The size is simply any 2 number sequence representing
the width and height.
<br>&nbsp;<br>
This transformation is not filtered.
</ul><br>&nbsp;<br>

<a name=scale2x><font size=+2><b>scale2x
</b></font><br><font size=+1><tt>
pygame.transform.scale2x(Surface) -> Surface
</tt></font><ul>
This will return a new image that is double the size of
the original. It uses the AdvanceMAME Scale2X algorithm
which does a 'jaggie-less' scale of bitmap graphics.
<br>&nbsp;<br>
This really only has an effect on simple images with solid
colors. On photographic and antialiased images it will look
like a regular unfiltered scale.
</ul><br>&nbsp;<br>


<hr>
</body></html>
