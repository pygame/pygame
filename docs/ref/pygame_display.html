<html>
<title>pygame.display</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellspacing=3 width=100%><tr><td bgcolor=#00000>
<table width=100%><tr><td bgcolor=c2fc20 align=center>
    <a href=http://www.pygame.org>
    <img src=../pygame_tiny.gif border=0 width=200 height=60></a><br>
    <b>pygame&nbsp;&nbsp;&nbsp;documentation</b>
</td><td bgcolor=6aee28 align=center valign=top width=100%>

	||&nbsp;
	<a href=http://www.pygame.org>Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<br>&nbsp;<br>

|| <a href=pygame.html>pygame</a> || 
<a href=pygame_cdrom.html>cdrom</a> || 
<a href=pygame_constants.html>constants</a> || 
<a href=pygame_display.html>display</a> || 
<a href=pygame_draw.html>draw</a> || 
<a href=pygame_event.html>event</a> ||<br>
|| <a href=pygame_font.html>font</a> || 
<a href=pygame_image.html>image</a> || 
<a href=pygame_joystick.html>joystick</a> || 
<a href=pygame_key.html>key</a> || 
<a href=pygame_mixer.html>mixer</a> || 
<a href=pygame_mixer_music.html>mixer_music</a> ||<br>
|| <a href=pygame_mouse.html>mouse</a> || 
<a href=pygame_movie.html>movie</a> || 
<a href=pygame_sndarray.html>sndarray</a> || 
<a href=pygame_surfarray.html>surfarray</a> || 
<a href=pygame_time.html>time</a> || 
<a href=pygame_transform.html>transform</a> ||<br>
&nbsp;<br>|| <a href=CD.html>CD</a> || 
<a href=Channel.html>Channel</a> || 
<a href=Clock.html>Clock</a> || 
<a href=Font.html>Font</a> || 
<a href=Joystick.html>Joystick</a> || 
<a href=Movie.html>Movie</a> ||<br>
|| <a href=Rect.html>Rect</a> || 
<a href=Sound.html>Sound</a> || 
<a href=Surface.html>Surface</a> ||<br>
&nbsp;<br>|| <a href=pygame_color.html>color</a> || 
<a href=pygame_cursors.html>cursors</a> || 
<a href=pygame_sprite.html>sprite</a> ||<br>


</td></tr></table></td></tr></table>
<br>
<h2 align=center>pygame.display</h2>
Contains routines to work with the display. Mainly used for
setting the display mode and updating the display surface.
<br>&nbsp;<br>
Pygame offers a fairly simple interface to the display buffer.
The buffer is represented as an offscreen surface to which you
can write directly. If you want the screen to show what you have
written, the <a href=#update>pygame.display.update()</a> function will guarantee the
the desired portion of the screen is updated. You can call
<a href=#flip>pygame.display.flip()</a> to update the entire screen, and also flip
a hardware surface created with DOUBLEBUF.
<br>&nbsp;<br>
There are a number of ways to start the video display. The
easiest way is to pick a common screen resolution and depth and
just initialize the video, checking for exceptions. You will
probably get what you want, but pygame may be emulating your
requested mode and converting the display on update (this is not
the fastest method). When calling <a href=#set_mode>pygame.display.set_mode()</a> with
the bit depth omitted or set to zero, pygame will determine the
best video mode available and set to that. You can also query for
more information on video modes with <a href=#mode_ok>pygame.display.mode_ok()</a>,
<a href=#list_modes>pygame.display.list_modes()</a>, and
<a href=#Info>pygame.display.Info()</a>.
<br>&nbsp;<br>
When using a display depth other than what you graphic resources
may be saved at, it is best to call the <a href=Surface.html#convert>Surface.convert()</a> routine
to convert them to the same format as the display, this will
result in the fastest blitting.
<br>&nbsp;<br>
Pygame currently supports any but depth >= 8 bits per pixl. 8bpp
formats are considered to be 8-bit palettized modes, while 12,
15, 16, 24, and 32 bits per pixel are considered 'packed pixel'
modes, meaning each pixel contains the RGB color componsents
packed into the bits of the pixel.
<br>&nbsp;<br>
After you have initialized your video mode, you can take the
surface that was returned and write to it like any other Surface
object. Be sure to call <a href=#update>update()</a> or <a href=#flip>flip()</a> to keep what is on the
screen synchronized with what is on the surface. Be sure not to call
display routines that modify the display surface while it is locked.

<hr>

<table>
<tr><td><a href=#Info>Info</a></td><td> -
get display capabilities and settings</td></tr>


<tr><td><a href=#flip>flip</a></td><td> -
update the display</td></tr>


<tr><td><a href=#get_active>get_active</a></td><td> -
get state of display mode</td></tr>


<tr><td><a href=#get_caption>get_caption</a></td><td> -
get the current title of the window</td></tr>


<tr><td><a href=#get_driver>get_driver</a></td><td> -
get the current sdl video driver</td></tr>


<tr><td><a href=#get_init>get_init</a></td><td> -
get status of display module initialization</td></tr>


<tr><td><a href=#get_surface>get_surface</a></td><td> -
get current display surface</td></tr>


<tr><td><a href=#gl_get_attribute>gl_get_attribute</a></td><td> -
get special OPENGL attributes</td></tr>


<tr><td><a href=#gl_set_attribute>gl_set_attribute</a></td><td> -
set special OPENGL attributes</td></tr>


<tr><td><a href=#iconify>iconify</a></td><td> -
minimize the display window</td></tr>


<tr><td><a href=#init>init</a></td><td> -
initialize the display module</td></tr>


<tr><td><a href=#list_modes>list_modes</a></td><td> -
query all resolutions for requested mode</td></tr>


<tr><td><a href=#mode_ok>mode_ok</a></td><td> -
query a specific display mode</td></tr>


<tr><td><a href=#quit>quit</a></td><td> -
uninitialize the display module</td></tr>


<tr><td><a href=#set_caption>set_caption</a></td><td> -
changes the title of the window</td></tr>


<tr><td><a href=#set_gamma>set_gamma</a></td><td> -
change the brightness of the display</td></tr>


<tr><td><a href=#set_gamma_ramp>set_gamma_ramp</a></td><td> -
advanced control over the display gamma ramps</td></tr>


<tr><td><a href=#set_icon>set_icon</a></td><td> -
changes the window manager icon for the window</td></tr>


<tr><td><a href=#set_mode>set_mode</a></td><td> -
set the display mode</td></tr>


<tr><td><a href=#set_palette>set_palette</a></td><td> -
set the palette</td></tr>


<tr><td><a href=#toggle_fullscreen>toggle_fullscreen</a></td><td> -
switch the display fullscreen mode</td></tr>


<tr><td><a href=#update>update</a></td><td> -
update an area of the display</td></tr>


</table>

<hr>

<a name=Info><font size=+2><b>Info
</b></font><br><font size=+1><tt>
pygame.display.Info() -> VidInfo
</tt></font><ul>
Gets a vidinfo object that contains information about the
capabilities and current state of the video driver. This can be
called before the display mode is set, to determine the current
video mode of a display.
You can print the VidInfo object to see all its members and values.
</ul><br>&nbsp;<br>

<a name=flip><font size=+2><b>flip
</b></font><br><font size=+1><tt>
pygame.display.flip() -> None
</tt></font><ul>
This will update the contents of the entire display. If your
display mode is using the flags HWSURFACE and DOUBLEBUF, this
will wait for a vertical retrace and swap the surfaces. If you
are using a different type of display mode, it will simply update
the entire contents of the surface.
<br>&nbsp;<br>
When using an OPENGL display mode this will perform a gl buffer swap.
</ul><br>&nbsp;<br>

<a name=get_active><font size=+2><b>get_active
</b></font><br><font size=+1><tt>
pygame.display.get_active() -> bool
</tt></font><ul>
Returns true if the current display is active on the screen. This
done with the call to <a href=#set_mode>pygame.display.set_mode()</a>. It is
potentially subject to the activity of a running window manager.
<br>&nbsp;<br>
Calling <a href=#set_mode>set_mode()</a> will change all existing display surface
to reference the new display mode. The old display surface will
be lost after this call.
</ul><br>&nbsp;<br>

<a name=get_caption><font size=+2><b>get_caption
</b></font><br><font size=+1><tt>
pygame.display.get_caption() -> title, icontitle
</tt></font><ul>
Returns the current title and icontitle for the display window.
</ul><br>&nbsp;<br>

<a name=get_driver><font size=+2><b>get_driver
</b></font><br><font size=+1><tt>
pygame.display.get_driver() -> name
</tt></font><ul>
Once the display is initialized, this will return the name of the
currently running video driver. There is no way to get a list of
all the supported video drivers.
</ul><br>&nbsp;<br>

<a name=get_init><font size=+2><b>get_init
</b></font><br><font size=+1><tt>
pygame.display.get_init() -> bool
</tt></font><ul>
Returns true if SDL's video system is currently intialized.
</ul><br>&nbsp;<br>

<a name=get_surface><font size=+2><b>get_surface
</b></font><br><font size=+1><tt>
pygame.display.get_surface() -> Surface
</tt></font><ul>
Returns a Surface object representing the current display. Will
return None if called before the display mode is set.
</ul><br>&nbsp;<br>

<a name=gl_get_attribute><font size=+2><b>gl_get_attribute
</b></font><br><font size=+1><tt>
pygame.display.gl_get_attribute(flag) -> value
</tt></font><ul>
After calling <a href=#set_mode>pygame.display.set_mode()</a> with the OPENGL flag
you will likely want to check the value of any special opengl
attributes you requested. You will not always get what you
requested.
<br>&nbsp;<br>
See <a href=#gl_set_attribute>pygame.display.gl_set_attribute()</a> for a list of flags.
<br>&nbsp;<br>
The OPENGL flags are; GL_ALPHA_SIZE, GL_DEPTH_SIZE, GL_STENCIL_SIZE,
GL_ACCUM_RED_SIZE, GL_ACCUM_GREEN_SIZE, GL_ACCUM_BLUE_SIZE, GL_ACCUM_ALPHA_SIZE,
GL_RED_SIZE, GL_GREEN_SIZE, GL_BLUE_SIZE, GL_DEPTH_SIZE
</ul><br>&nbsp;<br>

<a name=gl_set_attribute><font size=+2><b>gl_set_attribute
</b></font><br><font size=+1><tt>
pygame.display.gl_set_attribute(flag, value) -> None
</tt></font><ul>
When calling <a href=#set_mode>pygame.display.set_mode()</a> with the OPENGL flag,
pygame automatically handles setting the opengl attributes like
color and doublebuffering. OPENGL offers several other attributes
you may want control over. Pass one of these attributes as the
flag, and its appropriate value.
<br>&nbsp;<br>
This must be called before <a href=#set_mode>pygame.display.set_mode()</a>
<br>&nbsp;<br>
The OPENGL flags are; GL_ALPHA_SIZE, GL_DEPTH_SIZE, GL_STENCIL_SIZE,
GL_ACCUM_RED_SIZE, GL_ACCUM_GREEN_SIZE, GL_ACCUM_BLUE_SIZE, GL_ACCUM_ALPHA_SIZE
GL_MULTISAMPLEBUFFERS, GL_MULTISAMPLESAMPLES, GL_STEREO
</ul><br>&nbsp;<br>

<a name=iconify><font size=+2><b>iconify
</b></font><br><font size=+1><tt>
pygame.display.iconify() -> bool
</tt></font><ul>
Tells the window manager (if available) to minimize the
application. The call will return true if successful. You will
receive an APPACTIVE event on the event queue when the window has
been minimized.
</ul><br>&nbsp;<br>

<a name=init><font size=+2><b>init
</b></font><br><font size=+1><tt>
pygame.display.init() -> None
</tt></font><ul>
Manually initialize SDL's video subsystem. Will raise an
exception if it cannot be initialized. It is safe to call this
function if the video has is currently initialized.
</ul><br>&nbsp;<br>

<a name=list_modes><font size=+2><b>list_modes
</b></font><br><font size=+1><tt>
pygame.display.list_modes([depth, [flags]]) -> [[x,y],...] | -1
</tt></font><ul>
This function returns a list of possible dimensions for a
specified color depth. The return value will be an empty list if
no display modes are available with the given arguments. A return
value of -1 means that any requested resolution should work (this
is likely the case for windowed modes). Mode sizes are sorted
from biggest to smallest.
<br>&nbsp;<br>
If depth is not passed or 0, SDL will choose the current/best
color depth for the display. You will usually want to pass
FULLSCREEN when using the flags, if flags is omitted, FULLSCREEN
is the default.
</ul><br>&nbsp;<br>

<a name=mode_ok><font size=+2><b>mode_ok
</b></font><br><font size=+1><tt>
pygame.display.mode_ok(size, [flags, [depth]]) -> int
</tt></font><ul>
This uses the same arguments as the call to
<a href=#set_mode>pygame.display.set_mode()</a>. It is used to determine if a requested
display mode is available. It will return 0 if the requested mode
is not possible. Otherwise it will return the best and closest
matching bit depth for the mode requested.
<br>&nbsp;<br>
The size is a 2-number-sequence containing the width and height
of the desired display mode. Flags represents a set of different
options for the display mode. If omitted or given as 0, it will
default to a simple software window. You can mix several flags
together with the bitwise-or (|) operator. Possible flags are
HWSURFACE (or the value 1), HWPALETTE, DOUBLEBUF, and/or
FULLSCREEN. There are other flags available but these are the
most usual. A full list of flags can be found in the SDL
documentation. The optional depth arguement is the requested bits
per pixel. It will usually be left omitted, in which case the
display will use the best/fastest pixel depth available.
</ul><br>&nbsp;<br>

<a name=quit><font size=+2><b>quit
</b></font><br><font size=+1><tt>
pygame.display.quit() -> None
</tt></font><ul>
Manually uninitialize SDL's video subsystem. It is safe to call
this if the video is currently not initialized.
</ul><br>&nbsp;<br>

<a name=set_caption><font size=+2><b>set_caption
</b></font><br><font size=+1><tt>
pygame.display.set_caption(title, [icontitle]) -> None
</tt></font><ul>
If the display has a window title, this routine will change the
name on the window. Some environments support a shorter icon
title to be used when the display is minimized. If icontitle is
omittied it will be the same as caption title.
</ul><br>&nbsp;<br>

<a name=set_gamma><font size=+2><b>set_gamma
</b></font><br><font size=+1><tt>
pygame.display.set_gamma(r, [g, b]) -> bool
</tt></font><ul>
Sets the display gamma to the given amounts. If green and blue
are ommitted, the red value will be used for all three colors.
The color arguments are floating point values with 1.0 being the
normal value. If you are using a display mode with a hardware
palette, this will simply update the palette you are using. Not
all hardware supports gamma. The return value will be true on
success.
</ul><br>&nbsp;<br>

<a name=set_gamma_ramp><font size=+2><b>set_gamma_ramp
</b></font><br><font size=+1><tt>
pygame.display.set_gamma_ramp(r, g, b) -> bool
</tt></font><ul>
Pass three sequences with 256 elements. Each element must be a
'16bit' unsigned integer value. This is from 0 to 65536.
If you are using a display mode with a hardware
palette, this will simply update the palette you are using.
Not all hardware supports gamma. The return value will be
true on success.
</ul><br>&nbsp;<br>

<a name=set_icon><font size=+2><b>set_icon
</b></font><br><font size=+1><tt>
pygame.display.set_icon(Surface) -> None
</tt></font><ul>
Sets the runtime icon that your system uses to decorate
the program window. It is also used when the application
is iconified and in the window frame.
<br>&nbsp;<br>
You likely want this to be a smaller image, a size that
your system window manager will be able to deal with. It will
also use the Surface colorkey if available.
<br>&nbsp;<br>
Some window managers on X11 don't allow you to change the 
icon after the window has been shown the first time.
</ul><br>&nbsp;<br>

<a name=set_mode><font size=+2><b>set_mode
</b></font><br><font size=+1><tt>
pygame.display.set_mode(size, [flags, [depth]]) -> Surface
</tt></font><ul>
Sets the current display mode. If calling this after the mode has
already been set, this will change the display mode to the
desired type. Sometimes an exact match for the requested video
mode is not available. In this case SDL will try to find the
closest match and work with that instead.
<br>&nbsp;<br>
The size is a 2-number-sequence containing the width and height
of the desired display mode. Flags represents a set of different
options for the new display mode. If omitted or given as 0, it
will default to a simple software window. You can mix several
flags together with the bitwise-or (|) operator. Possible flags
are HWSURFACE (or the value 1), HWPALETTE, DOUBLEBUF, and/or
FULLSCREEN. There are other flags available but these are the
most usual. A full list of flags can be found in the pygame
documentation.
<br>&nbsp;<br>
The optional depth arguement is the requested bits
per pixel. It will usually be left omitted, in which case the
display will use the best/fastest pixel depth available.
<br>&nbsp;<br>
You can create an OpenGL surface (for use with PyOpenGL)
by passing the OPENGL flag. You will likely want to use the
DOUBLEBUF flag when using OPENGL. In which case, the <a href=#flip>flip()</a>
function will perform the GL buffer swaps. When you are using
an OPENGL video mode, you will not be able to perform most of the
pygame drawing functions (fill, set_at, etc) on the display surface.
</ul><br>&nbsp;<br>

<a name=set_palette><font size=+2><b>set_palette
</b></font><br><font size=+1><tt>
pygame.display.set_palette([[r, g, b], ...]) -> None
</tt></font><ul>
Displays with a HWPALETTE have two palettes. The display Surface
palette and the visible 'onscreen' palette.
<br>&nbsp;<br>
This will change the video display's visible colormap. It does
not effect the display Surface's base palette, only how it is
displayed. Setting the palette for the display Surface will
override this visible palette. Also passing no args will reset
the display palette back to the Surface's palette.
<br>&nbsp;<br>
You can pass an incomplete list of RGB values, and
this will only change the first colors in the palette.
</ul><br>&nbsp;<br>

<a name=toggle_fullscreen><font size=+2><b>toggle_fullscreen
</b></font><br><font size=+1><tt>
pygame.display.toggle_fullscreen() -> bool
</tt></font><ul>
Tells the window manager (if available) to switch between
windowed and fullscreen mode. If available and successfull, will
return true. Note, there is currently limited platform support
for this call.
</ul><br>&nbsp;<br>

<a name=update><font size=+2><b>update
</b></font><br><font size=+1><tt>
pygame.display.update([rectstyle]) -> None
</tt></font><ul>
This call will update a section (or sections) of the display
screen. You must update an area of your display when you change
its contents. If passed with no arguments, this will update the
entire display surface. If you have many rects that need
updating, it is best to combine them into a sequence and pass
them all at once. This call will accept a sequence of rectstyle
arguments. Any None's in the list will be ignored.
<br>&nbsp;<br>
This call cannot be used on OPENGL displays, and will generate
an exception.
</ul><br>&nbsp;<br>


<hr>
</body></html>
