<html>
<title>pygame.surfarray</title>
<body bgcolor=#aaeebb text=#000000 link=#331111 vlink=#331111>


<table cellspacing=3 width=100%><tr><td bgcolor=#00000>
<table width=100%><tr><td bgcolor=c2fc20 align=center>
    <a href=http://www.pygame.org>
    <img src=../pygame_tiny.gif border=0 width=200 height=60></a><br>
    <b>pygame&nbsp;&nbsp;&nbsp;documentation</b>
</td><td bgcolor=6aee28 align=center valign=top width=100%>

	||&nbsp;
	<a href=http://www.pygame.org>Home</a> &nbsp;||&nbsp;
	<a href=../index.html>Help Contents</a> &nbsp;||
	<br>&nbsp;<br>

|| <a href=pygame.html>pygame</a> || 
<a href=pygame_cdrom.html>cdrom</a> || 
<a href=pygame_constants.html>constants</a> || 
<a href=pygame_display.html>display</a> || 
<a href=pygame_draw.html>draw</a> || 
<a href=pygame_event.html>event</a> ||<br>
|| <a href=pygame_font.html>font</a> || 
<a href=pygame_image.html>image</a> || 
<a href=pygame_joystick.html>joystick</a> || 
<a href=pygame_key.html>key</a> || 
<a href=pygame_mixer.html>mixer</a> || 
<a href=pygame_mixer_music.html>mixer_music</a> ||<br>
|| <a href=pygame_mouse.html>mouse</a> || 
<a href=pygame_movie.html>movie</a> || 
<a href=pygame_sndarray.html>sndarray</a> || 
<a href=pygame_surfarray.html>surfarray</a> || 
<a href=pygame_time.html>time</a> || 
<a href=pygame_transform.html>transform</a> ||<br>
&nbsp;<br>|| <a href=CD.html>CD</a> || 
<a href=Channel.html>Channel</a> || 
<a href=Clock.html>Clock</a> || 
<a href=Font.html>Font</a> || 
<a href=Joystick.html>Joystick</a> || 
<a href=Movie.html>Movie</a> ||<br>
|| <a href=Rect.html>Rect</a> || 
<a href=Sound.html>Sound</a> || 
<a href=Surface.html>Surface</a> ||<br>
&nbsp;<br>|| <a href=pygame_color.html>color</a> || 
<a href=pygame_cursors.html>cursors</a> || 
<a href=pygame_sprite.html>sprite</a> ||<br>


</td></tr></table></td></tr></table>
<br>
<h2 align=center>pygame.surfarray</h2>
Contains routines for mixing numeric arrays with
surfaces. You can create arrays that directly reference
the pixel data of an image. Sometimes this can be limited
to the pixel format of the Surface, so you can also create
independent copies from any format.
<br>&nbsp;<br>
The image arrays are indexes 'X' axis first. This is different
than traditional C memory access, where images are often indexed
with the 'Y' axis first. All this means is to access pixel values
in the array, you index them as 'X, Y' pairs. myarray[10,20] will
provide you the pixel at 10, 20 in the image. If you prefer to
work with the traditional framebuffer indices, use the arrays
'transpose()' method to create the alternate view of the pixel
data.
<br>&nbsp;<br>

<hr>

<table>
<tr><td><a href=#array2d>array2d</a></td><td> -
get a 2d array copied from a surface</td></tr>


<tr><td><a href=#array3d>array3d</a></td><td> -
get a 3d array copied from a surface</td></tr>


<tr><td><a href=#array_alpha>array_alpha</a></td><td> -
get an array with a surface pixel alpha values</td></tr>


<tr><td><a href=#array_colorkey>array_colorkey</a></td><td> -
get an array with a surface colorkey values</td></tr>


<tr><td><a href=#blit_array>blit_array</a></td><td> -
quickly transfer an array to a Surface</td></tr>


<tr><td><a href=#make_surface>make_surface</a></td><td> -
create a new Surface from array data</td></tr>


<tr><td><a href=#map_array>map_array</a></td><td> -
map an array with RGB values into mapped colors</td></tr>


<tr><td><a href=#pixels2d>pixels2d</a></td><td> -
get a 2d reference array to a surface</td></tr>


<tr><td><a href=#pixels3d>pixels3d</a></td><td> -
get a 3d reference array to a surface</td></tr>


<tr><td><a href=#pixels_alpha>pixels_alpha</a></td><td> -
get a reference array to a surface alpha data</td></tr>


</table>

<hr>

<a name=array2d><font size=+2><b>array2d
</b></font><br><font size=+1><tt>
pygame.surfarray.array2d(Surface) -> Array
</tt></font><ul>
This returns a new contigous 2d array. Think of it
as a 2d image array with a mapped pixel value at
each index.
<br>&nbsp;<br>
This function will temporarily lock the surface.
</ul><br>&nbsp;<br>

<a name=array3d><font size=+2><b>array3d
</b></font><br><font size=+1><tt>
pygame.surfarray.array3d(Surface) -> Array
</tt></font><ul>
This returns a new contigous 3d array. Think of it
as a 2d image array with an RGB array for each
pixel value.
<br>&nbsp;<br>
This function will temporarily lock the surface.
</ul><br>&nbsp;<br>

<a name=array_alpha><font size=+2><b>array_alpha
</b></font><br><font size=+1><tt>
pygame.surfarray.array_alpha(Surface) -> Array
</tt></font><ul>
This returns a new contigous 2d array with the
alpha values of an image as unsigned bytes. If the
surface has no alpha, an array of all opaque values
is returned.
<br>&nbsp;<br>
This function will temporarily lock the surface.
</ul><br>&nbsp;<br>

<a name=array_colorkey><font size=+2><b>array_colorkey
</b></font><br><font size=+1><tt>
pygame.surfarray.array_colorkey(Surface) -> Array
</tt></font><ul>
This returns a new contigous 2d array with the
colorkey values of an image as unsigned bytes. If the
surface has no colorkey, an array of all opaque values
is returned. Otherwise the array is either 0's or 255's.
<br>&nbsp;<br>
This function will temporarily lock the surface.
</ul><br>&nbsp;<br>

<a name=blit_array><font size=+2><b>blit_array
</b></font><br><font size=+1><tt>
pygame.surfarray.blit_array(surf, array) -> None
</tt></font><ul>
Transfer an array of any type (3d or 2d) onto a
Surface. The array must be the same dimensions as
the destination Surface. While you can assign the
values of an array to the pixel referenced arrays,
using this blit method will usually be quicker
because of it's smarter handling of noncontiguous
arrays. Plus it allows you to blit from any image
array type to any surface format in one step, no
internal conversions.
<br>&nbsp;<br>
This function will temporarily lock the surface.
</ul><br>&nbsp;<br>

<a name=make_surface><font size=+2><b>make_surface
</b></font><br><font size=+1><tt>
pygame.surfarray.make_surface(array) -> Surface
</tt></font><ul>
Create a new software surface that closely resembles
the data and format of the image array data.
</ul><br>&nbsp;<br>

<a name=map_array><font size=+2><b>map_array
</b></font><br><font size=+1><tt>
pygame.surfarray.map_array(surf, array3d) -> array2d
</tt></font><ul>
Create a new array with the RGB pixel values of a
3d array into mapped color values in a 2D array.
<br>&nbsp;<br>
Just so you know, this can also map a 2D array
with RGB values into a 1D array of mapped color
values
</ul><br>&nbsp;<br>

<a name=pixels2d><font size=+2><b>pixels2d
</b></font><br><font size=+1><tt>
pygame.surfarray.pixels2d(Surface) -> Array
</tt></font><ul>
This returns a new noncontigous 2d array that
directly effects a Surface's contents. Think of it
as a 2d image array with a mapped pixel value at
each index.
<br>&nbsp;<br>
This will not work on 24bit surfaces, since there
is no native 24bit data type to access the pixel
values.
<br>&nbsp;<br>
This function will lock the given surface, and it
will remained locked for as long as the pixel array
exists
</ul><br>&nbsp;<br>

<a name=pixels3d><font size=+2><b>pixels3d
</b></font><br><font size=+1><tt>
pygame.surfarray.pixels3d(Surface) -> Array
</tt></font><ul>
This returns a new noncontigous 3d array that
directly effects a Surface's contents. Think of it
as a 2d image array with an RGB array for each
pixel value.
<br>&nbsp;<br>
This will only work for 24 and 32 bit surfaces,
where the RGB components can be accessed as 8-bit
components.
<br>&nbsp;<br>
This function will lock the given surface, and it
will remained locked for as long as the pixel array
exists
</ul><br>&nbsp;<br>

<a name=pixels_alpha><font size=+2><b>pixels_alpha
</b></font><br><font size=+1><tt>
pygame.surfarray.pixels_alpha(Surface) -> Array
</tt></font><ul>
This returns a new noncontigous array that directly
effects a Surface's alpha contents.
<br>&nbsp;<br>
This will only work for 32bit surfaces with a pixel
alpha channel enabled.
<br>&nbsp;<br>
This function will lock the given surface, and it
will remained locked for as long as the pixel array
exists
</ul><br>&nbsp;<br>


<hr>
</body></html>
